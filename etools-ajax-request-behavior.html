<link rel="import" href="es6-obj-assign-polyfil.html">
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-ajax/iron-request.html">
<link rel="import" href="../etools-behaviors/etools-logs-behavior.html">
<link rel="import" href="etools-ajax-data-behavior.html">
<link rel="import" href="etools-ajax-cache-behavior.html">

<script>
  (function(window) {
    'use strict';

    function EtoolsRequestError(error, statusCode, statusText, response) {
      this.error = error;
      this.status = statusCode;
      this.statusText = statusText;
      this.response = _prepareResponse(response);
    }

    function _prepareResponse(response) {
      try {
        return JSON.parse(response);
      } catch (e) {
        return response;
      }
    }

    function defineEtoolsRequest() {
      var etoolsRequest = {
        properties: {
          lastAjaxRequest: {
            type: Object,
            notify: true,
            readOnly: true
          },
          activeAjaxRequests: {
            type: Array,
            readOnly: true,
            value: function() {
              return [];
            }
          },
          reqProgress: {
            type: Object,
            notify: true,
            readOnly: true,
            value: function() {
              return null;
            }
          },
          checkReqProgress: {
            type: Object,
            value: function() {
              return null;
            }
          }
        },

        /**
         * Check for cached data if needed, if no cached data then fire new request
         * returns Promise
         */
        sendRequest: function(reqConfig, activeReqKey) {
          // prepare request config options
          var preparedConfigOptions = this._prepareConfigOptions(reqConfig);
          var reqConfigOptions = preparedConfigOptions.ironRequestOptions;
          var cachingInfo = preparedConfigOptions.cachingInfo;

          var self = this;
          if (this._isViableForCaching(cachingInfo)) {
            // we might have data cached; if cached data is available and not expired
            // return it without making the request
            return this.getEndpointDataFromCache(cachingInfo).then(function(response) {
              if (!response) {
                return self._doRequest(reqConfigOptions, cachingInfo, reqConfig.checkProgress);
              }
              return response;
            });
          }
          // make request
          return this._doRequest(reqConfigOptions, cachingInfo, reqConfig.checkProgress, activeReqKey);
        },

        /**
         * Fire new request
         */
        _doRequest: function(reqConfigOptions, cachingInfo, checkProgress, activeReqKey) {
          var request = /** @type {!IronRequestElement} */ (document.createElement('iron-request'));
          this._checkRequestProgress(request, checkProgress);
          var self = this;
          request.send(reqConfigOptions);
          this._setLastAjaxRequest(request);
          this._addToActiveAjaxRequests(activeReqKey, request);

          return request.completes.then(function(request) {
            var responseData = request.response;

            if (reqConfigOptions.handleAs === 'json' && typeof responseData === 'string') {
              responseData = _prepareResponse(responseData);
            }

            if (self._isViableForCaching(cachingInfo)) {
              // add/cache response data into dexie db
              return self.cacheEndpointData(responseData, cachingInfo);
            }

            self._removeActiveRequestFromList(activeReqKey);

            return responseData;
          }).catch(function(request, error) {
            self._removeActiveRequestFromList(activeReqKey);
            // request failed
            // check request aborted, no error handling in this case
            if (!request.aborted) {
              throw new EtoolsRequestError(error, request.xhr.status, request.xhr.statusText, request.xhr.response);
            }
          }.bind(this, request));
        },

        _addToActiveAjaxRequests: function(key, request) {
          if (key) {
            this.push('activeAjaxRequests', {key: key, request: request});
          }
        },

        _removeActiveRequestFromList: function(key) {
          if (key) {
            var req = this._getActiveRequestByKey(key);
            if (req) {
              var requestIndex = this.activeAjaxRequests.indexOf(req);
              if (requestIndex > -1) {
                this.splice('activeAjaxRequests', requestIndex, 1);
              }
            }
          }
        },

        _getActiveRequestByKey: function(key) {
          return this.activeAjaxRequests.find(function(activeReqMapObj) {
            return activeReqMapObj.key === key;
          });
        },

        abortRequest: function(key) {
          // abort last request if key is not provided
          var req = this.lastAjaxRequest;
          if (key) {
            req = this._getActiveRequestByKey(key);
          }
          if (req) {
            req.abort();
          }
        },

        _isViableForCaching: function(cachingInfo) {
          return cachingInfo && cachingInfo.requestIsViableForCaching &&
              this.cachingCanBeMade(cachingInfo.cacheTableName);
        },

        _prepareConfigOptions: function(reqConfig) {
          return {
            ironRequestOptions: {
              url: this._getRequestUrl(reqConfig),
              method: reqConfig.method || 'GET',
              headers: this._getRequestHeaders(reqConfig),
              body: this._getRequestBody(reqConfig),
              async: !reqConfig.sync,
              handleAs: this._getHandleAs(reqConfig),
              jsonPrefix: reqConfig.jsonPrefix || '',
              withCredentials: !!reqConfig.withCredentials,
              timeout: reqConfig.timeout || 0
            },
            cachingInfo: this.getCachingInfo(reqConfig)
          };
        },

        _getHandleAs: function(reqConfig) {
          var handleAs = reqConfig.handleAs || 'json';
          if (reqConfig.downloadCsv)
            handleAs = 'blob';
          return handleAs;
        },

        _getRequestUrl: function(reqConfig) {
          var url = '';
          if (reqConfig.endpoint && reqConfig.endpoint.url) {
            url = reqConfig.endpoint.url;
            url += this._buildQueryString(url, reqConfig.params);
          }
          return url;
        },

        _buildQueryString: function(url, params) {
          var queryStr = '';
          if (!params || !this._isNonEmptyObject(params)) {
            return '';
          }
          if (url.indexOf('?') < 0) {
            queryStr = '?';
          } else {
            queryStr = '&';
          }
          for (var key in params) {
            queryStr += key + '=' + params[key] + '&';
          }

          // remove trailing &
          queryStr = queryStr.substring(0, queryStr.length - 1);
          return queryStr;
        },

        _getRequestBody: function(reqConfig) {
          var body = reqConfig.body || {};
          if (reqConfig.multiPart) {
            body = this._prepareMultiPartFormData(body, reqConfig.prepareMultipartData);
          }
          return body;
        },

        _getRequestHeaders: function(reqConfig) {
          var headers = {};

          headers['content-type'] = this._determineContentType(reqConfig.body, reqConfig.multiPart);

          if (reqConfig.downloadCsv) {
            headers['accept'] = 'text/csv';
            headers['content-type'] = 'text';
          }

          var clientConfiguredHeaders = this._getClientConfiguredHeaders(reqConfig.headers);
          var csrfHeaders = {};
          if (!this._csrfSafeMethod(reqConfig.method)) {
            csrfHeaders = this._getCsrfHeader(reqConfig.csrfCheck);
          }
          headers = Object.assign({}, headers, clientConfiguredHeaders, csrfHeaders);

          if (reqConfig.multiPart) {
            // content type will be automatically set in this case
            delete headers['content-type'];
          }

          return headers;
        },

        _getClientConfiguredHeaders: function(additionalHeaders) {
          var header;
          var clientHeaders = {};
          if (additionalHeaders && additionalHeaders instanceof Object) {
            for (header in additionalHeaders) {
              clientHeaders[header] = additionalHeaders[header].toString();
            }
          }
          return clientHeaders;
        },

        _getCsrfHeader: function(csrfCheck) {
          var csrfHeaders = {};
          if (csrfCheck !== 'disabled') {
            var csrfToken = this._getCSRFCookie();

            if (csrfToken) {
              csrfHeaders['x-csrftoken'] = csrfToken;
            }
          }
          return csrfHeaders;
        },

        _csrfSafeMethod: function(method) {
          // these HTTP methods do not require CSRF protection
          return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));
        },

        _getCSRFCookie: function() {
          // check for a csrftoken cookie and return its value
          var csrfCookieName = 'csrftoken';
          var csrfToken = null;
          if (document.cookie && document.cookie !== '') {
            var cookies = document.cookie.split(';');
            for (var i = 0; i < cookies.length; i++) {
              var cookie = cookies[i].trim();
              // Does this cookie string begin with the name we want?
              if (cookie.substring(0, csrfCookieName.length + 1) === (csrfCookieName + '=')) {
                csrfToken = decodeURIComponent(cookie.substring(csrfCookieName.length + 1));
                break;
              }
            }
          }
          return csrfToken;
        },

        /**
         * Content-Type set here can be overridden later
         * by headers sent from the client
         */
        _determineContentType: function(body) {
          var contentType = 'application/json';

          if (typeof body === 'string') {
            contentType = 'application/x-www-form-urlencoded';
          }

          return contentType;
        },

        _checkRequestProgress: function(request, checkProgress) {
          if (!checkProgress || !request || !request.progress) {
            return;
          }
          this.checkReqProgress = setInterval(function() {
            if (request.progress.constructor === Object && Object.keys(request.progress).length > 0) {
              this._setReqProgress(request.progress);
              if (!request.progress.lengthComputable || request.progress.loaded === request.progress.total) {
                this._stopReqProgressCheck();
              }
            }
          }.bind(this), 0);
        },
        _stopReqProgressCheck: function() {
          if (this.checkReqProgress) {
            clearInterval(this.checkReqProgress);
          }
        }
      };

      return etoolsRequest;
    }

    /** @polymerBehavior EtoolsAjaxRequestBehavior */
    window.EtoolsAjaxRequestBehavior = window.EtoolsAjaxRequestBehavior ||
        [EtoolsLogsBehavior, EtoolsAjaxDataBehavior, EtoolsAjaxCacheBehavior, defineEtoolsRequest()] || {};
    // the || {} at the end is there to make the linter happy
  })(window);
</script>
